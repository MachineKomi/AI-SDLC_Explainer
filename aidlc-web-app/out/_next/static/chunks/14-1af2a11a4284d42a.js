"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[14],{5312:function(e,n,t){t.d(n,{Lh:function(){return i},ch:function(){return s}});let i=[{id:"aidlc-overview",title:"AI-DLC Overview",description:"Learn the fundamentals of AI-Driven Development Lifecycle",sections:[{id:"what-is-aidlc",title:"What is AI-DLC?",content:'AI-DLC (AI-Driven Development Lifecycle) is a transformative approach\nto software development that positions AI as a central collaborator.\n\nKey characteristics:\n• AI proposes plans, asks clarifying questions, then implements\n• Humans own decisions and outcomes; AI executes within bounds\n• Not "SDLC + copilots" — a fundamentally different workflow\n• Artifacts persist in-repo, not in chat history\n\nThe core mental model:\n  AI creates plan → Asks questions → Implements after validation\n  \nThis pattern repeats rapidly for every SDLC activity.'},{id:"three-phases",title:"The Three Phases",content:"AI-DLC organizes work into three phases, each with specific goals:\n\n• INCEPTION: Determines WHAT to build and WHY\n  - Requirements analysis and validation\n  - User stories and unit decomposition\n  - Risk assessment\n\n• CONSTRUCTION: Determines HOW to build it\n  - Detailed design per unit\n  - Code generation and implementation\n  - Build-and-test loops\n\n• OPERATIONS: Deployment and monitoring\n  - Infrastructure as Code\n  - CI/CD pipelines\n  - Observability setup",diagram:"┌─────────────┐      ┌─────────────┐      ┌─────────────┐\n│  INCEPTION  │ ───▶ │CONSTRUCTION │ ───▶ │ OPERATIONS  │\n│  (What/Why) │      │    (How)    │      │  (Run/Mon)  │\n└─────────────┘      └─────────────┘      └─────────────┘\n       │                   │                    │\n       ▼                   ▼                    ▼\n   ┌───────┐           ┌───────┐           ┌───────┐\n   │ GATE  │           │ GATE  │           │ GATE  │\n   └───────┘           └───────┘           └───────┘"},{id:"gates",title:"Gates & Approvals",content:'Every phase has mandatory GATES requiring human approval.\n\nCore principles:\n• Plan-first, stage-by-stage execution\n• Every meaningful step needs an approval checkpoint\n• "Proof over prose" — evidence required, not just claims\n\nGate examples:\n• Inception Exit: Requirements + units approved\n• Unit Done: Tests green + acceptance criteria met\n• Production Ready: Deployable + observable + rollbackable\n\nBenefits of strict gates:\n• Prevents AI from "running away" with wrong assumptions\n• Creates audit trail of decisions\n• Ensures human accountability at every critical point',diagram:"   ┌──────────┐     ┌──────────┐     ┌──────────┐\n   │  PLAN    │ ──▶ │  GATE    │ ──▶ │ EXECUTE  │\n   │ (AI)     │     │ (Human)  │     │  (AI)    │\n   └──────────┘     └──────────┘     └──────────┘\n        ▲                                  │\n        └──────────────────────────────────┘\n                    repeat"},{id:"artifacts",title:"Artifacts",content:"Persisted artifacts are FIRST-CLASS in AI-DLC.\n\nAll lifecycle artifacts live in your repository:\n\n• aidlc-state.md — Current phase/stage + what's next\n• execution-plan.md — Approved stage checklist\n• audit.md — Append-only decisions and evidence\n• prompts.md — Log of all prompts given to AI\n\nPhase-specific artifacts:\n• inception/ — Intent, requirements, NFRs, units\n• construction/ — Design docs, task plans, validation\n• operations/ — Deployment plans, runbooks\n\nWhy artifacts matter:\n• Durable context (not lost in chat)\n• Reviewable by humans and future AI sessions\n• Auditable trail of decisions",diagram:"aidlc-docs/\n├── aidlc-state.md\n├── execution-plan.md  \n├── audit.md\n├── prompts.md\n├── inception/\n│   ├── intent.md\n│   ├── requirements.md\n│   ├── nfr.md\n│   └── units/\n├── construction/\n│   └── unit-01/\n│       ├── design.md\n│       └── tasks-plan.md\n└── operations/\n    └── deployment-plan.md"},{id:"roles",title:"Roles",content:'AI-DLC transforms team roles from "doing" to "approving and designing."\n\nKey roles (minimal set):\n\n• Product/Domain Owner\n  - Owns intent, success metrics, scope boundaries\n  \n• Tech Lead / Architect\n  - Owns unit boundaries, NFRs, integration decisions\n  \n• Engineer(s)\n  - Own implementation reviews, tests, code quality\n  \n• QA\n  - Owns test strategy and acceptance evidence\n  \n• Security\n  - Owns threat modeling and security controls\n  \n• Ops/SRE  \n  - Owns deployability and observability\n  \n• AI Workflow Maintainer\n  - Owns prompts, rules, and guardrails as code'},{id:"mental-model",title:"The Mental Model",content:'The core AI-DLC mental model is a repeating cycle:\n\n1. AI CREATES A PLAN (Level 1, then Level 2...)\n   - Detailed work breakdown with checkpoints\n   - Progressive enrichment at each level\n   \n2. AI ASKS CLARIFYING QUESTIONS  \n   - Structured Q&A in dedicated files\n   - Seeks missing context before proceeding\n   \n3. HUMAN VALIDATES AND APPROVES\n   - Reviews plan, answers questions, gives go-ahead\n   - Critical decisions require explicit sign-off\n   \n4. AI IMPLEMENTS IN "BOLTS"\n   - Bolt = smallest iteration (hours/days, not weeks)\n   - Executes only what was approved\n   \n5. AI PROVES RESULTS\n   - Tests passing, checks green, criteria met\n   - Runtime validation, not just prose claims\n\nKey insight: AI proposes, humans decide. Each step produces\nricher artifacts that become context for the next step.',diagram:"        ┌─────────────────────────────────────┐\n        │                                     │\n        ▼                                     │\n   ┌─────────┐    ┌─────────┐    ┌─────────┐  │\n   │  PLAN   │───▶│   ASK   │───▶│VALIDATE │  │\n   │  (AI)   │    │  (AI)   │    │ (Human) │  │\n   └─────────┘    └─────────┘    └─────────┘  │\n                                      │       │\n                                      ▼       │\n                               ┌─────────┐    │\n                               │IMPLEMENT│────┘\n                               │ (BOLT)  │\n                               └─────────┘"},{id:"summary",title:"Summary & Key Takeaways",content:'Congratulations! You\'ve completed the AI-DLC Overview.\n\nKEY TAKEAWAYS:\n\n1. AI-DLC has 3 phases: Inception, Construction, Operations\n\n2. Gates require human approval before proceeding\n\n3. Artifacts persist in-repo, not in chat\n\n4. 10 core principles guide the methodology\n   (Plan-first, proof over prose, small units, etc.)\n\n5. Roles shift from "doing" to "approving and designing"\n\n6. The mental model: AI proposes → Human approves → AI executes\n\nNEXT STEPS:\n• Explore the Phases section for deep dives\n• Review the 10 Principles  \n• Try the Quiz to test your knowledge',diagram:"╭───────────────────────────────────────────╮\n│                                           │\n│   ✓ Lesson Complete: AI-DLC Overview     │\n│                                           │\n│   You learned about:                      │\n│   • The three phases                      │\n│   • Gates and approvals                   │\n│   • Artifact model                        │\n│   • Team roles                            │\n│   • Core mental model                     │\n│                                           │\n╰───────────────────────────────────────────╯"}]},{id:"principles",title:"10 Core Principles",description:"Master the fundamental principles that guide AI-DLC",sections:[{id:"principle-intro",title:"The 10 Principles",content:"AI-DLC is guided by 10 core principles that ensure quality, \naccountability, and effective collaboration between humans and AI.\n\nThese principles are derived from AWS best practices and \nreal-world practitioner experience.\n\nLet's explore each one in detail.",diagram:"╭─────────────────────────────────────────────────────────────╮\n│                    10 CORE PRINCIPLES                        │\n├─────────────────────────────────────────────────────────────┤\n│  1. Plan-First          │  6. Proof over Prose             │\n│  2. Human Accountability │  7. Auditable Trail              │\n│  3. Small Batches        │  8. Context Persistence          │\n│  4. Adaptive Depth       │  9. Fail Fast, Recover Fast      │\n│  5. Structured Q&A       │ 10. Prompts as Code              │\n╰─────────────────────────────────────────────────────────────╯"},{id:"principle-1",title:"1. Plan-First",content:'PRINCIPLE: Always create a plan before executing.\n\nWhat it means:\n• AI proposes detailed work breakdown BEFORE any code\n• Plans include checkpoints and approval gates\n• Humans review and approve plans, not just results\n\nWhy it matters:\n• Prevents "AI running away" with wrong assumptions\n• Gives humans visibility into AI\'s intended approach\n• Creates natural review points\n\nAnti-pattern:\n• "Just implement feature X" without seeing the plan first\n• AI coding without explicit approval of approach',diagram:'    ┌──────────────────────────────────────────────┐\n    │                                              │\n    │   ❌ BAD:   "Build me a login page"          │\n    │                                              │\n    │   ✓ GOOD:  "Create a plan for login page    │\n    │            with checkpoints. Stop for        │\n    │            approval before coding."          │\n    │                                              │\n    └──────────────────────────────────────────────┘'},{id:"principle-2",title:"2. Human Accountability",content:"PRINCIPLE: Humans own decisions and outcomes; AI executes.\n\nWhat it means:\n• Every critical decision has a human approver\n• AI proposes, humans dispose\n• Accountability cannot be delegated to AI\n\nKey decisions requiring human sign-off:\n• Requirements scope\n• Architecture choices\n• Security controls\n• Go/no-go for deployment\n\nWhy it matters:\n• Legal and ethical responsibility stays with humans\n• AI hallucinations don't become production bugs\n• Clear ownership of outcomes",diagram:"    ┌─────────────────────────────────────────┐\n    │           ACCOUNTABILITY MODEL          │\n    ├─────────────────────────────────────────┤\n    │                                         │\n    │   AI OWNS:          │   HUMAN OWNS:     │\n    │   • Execution       │   • Decisions     │\n    │   • Code generation │   • Approvals     │\n    │   • Test running    │   • Outcomes      │\n    │   • Documentation   │   • Accountability│\n    │                                         │\n    └─────────────────────────────────────────┘"},{id:"principle-3",title:"3. Small Batches",content:"PRINCIPLE: Decompose work into small, reviewable units.\n\nWhat it means:\n• Break large tasks into units of 1-3 days work\n• Each unit has clear acceptance criteria\n• Review happens per-unit, not per-project\n\nBenefits:\n• Easier to review and verify\n• Faster feedback loops\n• Lower risk of large-scale errors\n• Progress is measurable\n\nSizing guidelines:\n• Too small: Overhead exceeds value\n• Too large: Can't review effectively\n• Just right: Reviewable in one sitting",diagram:'    ❌ BAD: One giant "Build the app" task\n    \n    ✓ GOOD: Decomposed units\n    \n    ┌──────────┐  ┌──────────┐  ┌──────────┐\n    │ Unit 1   │  │ Unit 2   │  │ Unit 3   │\n    │ Auth     │  │ Dashboard│  │ API      │\n    │ (2 days) │  │ (2 days) │  │ (1 day)  │\n    └────┬─────┘  └────┬─────┘  └────┬─────┘\n         │             │             │\n         ▼             ▼             ▼\n      Review        Review        Review'},{id:"principle-4",title:"4. Adaptive Depth",content:'PRINCIPLE: Match rigor to risk and complexity.\n\nWhat it means:\n• Stage selection is BINARY (execute or skip)\n• Detail level WITHIN stages adapts to problem\n• Workflow Planning decides which stages run\n\nFactors influencing depth:\n• Request clarity - How complete is the ask?\n• Problem complexity - How intricate is the solution?\n• Scope - Single file, component, or system-wide?\n• Risk level - What\'s the impact of errors?\n• Available context - Greenfield vs brownfield?\n\nKey insight from AWS:\n"Create exactly the detail needed for the problem at \nhand - no more, no less."',diagram:"    STAGE SELECTION (Binary)      DETAIL LEVEL (Adaptive)\n    ─────────────────────         ─────────────────────────\n    \n    Workflow Planning decides:     Within each stage:\n    \n    ┌─────────────┐               Simple → Concise artifacts\n    │   EXECUTE   │               Complex → Comprehensive \n    └─────────────┘                         artifacts\n          or\n    ┌─────────────┐               Model decides based on\n    │    SKIP     │               problem characteristics\n    └─────────────┘"},{id:"principle-5",title:"5. Structured Q&A",content:"PRINCIPLE: Use file-based, structured questions.\n\nWhat it means:\n• AI asks questions in structured format\n• Answers persist in files, not chat\n• Multiple-choice where possible\n\nBenefits:\n• Answers are reviewable and auditable\n• Can be validated mechanically\n• Context persists across sessions\n• Stakeholders can review asynchronously\n\nFormat example:\n• Questions go in: requirement-verification-questions.md\n• Answers have structured tags: <!-- ANSWER: B -->\n• Both persist in repository",diagram:"    requirement-verification-questions.md:\n    ┌────────────────────────────────────────────┐\n    │ Q1: Primary deployment target?             │\n    │     A) AWS Lambda                          │\n    │     B) Kubernetes                          │\n    │     C) On-premise                          │\n    │                                            │\n    │ <!-- ANSWER: B -->                         │\n    │ <!-- RATIONALE: Existing K8s cluster -->   │\n    └────────────────────────────────────────────┘"},{id:"principle-6",title:"6. Proof over Prose",content:'PRINCIPLE: Evidence required, not just claims.\n\nWhat it means:\n• Don\'t accept "it works" — require proof\n• Tests must pass, not just exist\n• Validation reports show actual results\n\nExamples of proof:\n• Test output showing all green\n• Screenshots of working UI\n• Logs showing successful deployment\n• Metrics showing performance targets met\n\nWhy it matters:\n• AI can be confidently wrong\n• Prose can mask incomplete work\n• Evidence is verifiable',diagram:'    ❌ PROSE (not acceptable):\n    "I\'ve implemented the login feature and it works."\n    \n    ✓ PROOF (acceptable):\n    ┌─────────────────────────────────────────┐\n    │ $ pytest tests/ -v                      │\n    │ ============================            │\n    │ test_login_success PASSED               │\n    │ test_login_invalid_password PASSED      │\n    │ test_login_rate_limit PASSED            │\n    │ ============================            │\n    │ 3 passed in 0.45s                       │\n    └─────────────────────────────────────────┘'},{id:"principle-7",title:"7. Auditable Trail",content:"PRINCIPLE: Maintain append-only decision logs.\n\nWhat it means:\n• Every decision gets logged with timestamp\n• audit.md is append-only (never edited)\n• Include: decision, rationale, evidence, approver\n\nWhat to log:\n• Phase transitions\n• Gate approvals/rejections\n• Scope changes\n• Architecture decisions\n• Security exceptions\n\nWhy it matters:\n• Compliance and governance\n• Post-mortems and debugging\n• Knowledge transfer\n• Legal protection",diagram:"    audit.md (append-only):\n    ┌─────────────────────────────────────────────────┐\n    │ ## 2026-01-28 | Unit 01 Approved                │\n    │                                                 │\n    │ Decision: Approve unit for implementation       │\n    │ Rationale: Requirements clear, AC defined       │\n    │ Evidence: requirements.md reviewed              │\n    │ Approver: @tech-lead                            │\n    │ ─────────────────────────────────────────────── │\n    │ ## 2026-01-28 | Architecture Decision           │\n    │                                                 │\n    │ Decision: Use PostgreSQL over MongoDB           │\n    │ Rationale: Strong consistency requirements      │\n    │ ...                                             │\n    └─────────────────────────────────────────────────┘"},{id:"principle-8",title:"8. Context Persistence",content:'PRINCIPLE: Artifacts persist in-repo, not in chat.\n\nWhat it means:\n• All context lives in files, not conversation\n• New sessions can resume from artifacts\n• Chat history is ephemeral; artifacts are durable\n\nKey artifacts:\n• aidlc-state.md — Current position\n• execution-plan.md — What\'s planned\n• audit.md — What happened\n• prompts.md — What was asked\n\nBenefits:\n• No "context window" limitations\n• Team members can onboard easily\n• AI sessions are reproducible\n• Version control applies',diagram:"    ❌ EPHEMERAL (chat):\n    ┌─────────────────────────────────────┐\n    │ User: Build a login page            │\n    │ AI: Here's the code...              │\n    │ User: Add remember me               │\n    │ AI: Updated...                      │\n    │ [SESSION ENDS - CONTEXT LOST]       │\n    └─────────────────────────────────────┘\n    \n    ✓ PERSISTENT (artifacts):\n    ┌─────────────────────────────────────┐\n    │ aidlc-docs/                         │\n    │ ├── aidlc-state.md    ← position    │\n    │ ├── audit.md          ← history     │\n    │ └── construction/     ← work        │\n    │ [SESSION ENDS - CONTEXT PRESERVED]  │\n    └─────────────────────────────────────┘"},{id:"principle-9",title:"9. Fail Fast, Recover Fast",content:"PRINCIPLE: Detect problems early, have rollback plans.\n\nWhat it means:\n• Run validations at every stage\n• Don't proceed on failing checks\n• Always have a way to undo\n\nValidation points:\n• Lint checks before commit\n• Tests before merge\n• Smoke tests before deploy\n• Canary before full rollout\n\nRecovery mechanisms:\n• Git revert for code\n• Blue-green deployments\n• Feature flags for rollback\n• Database migrations with down path",diagram:"    FAIL FAST:\n    ┌───────┐   ┌───────┐   ┌───────┐   ┌───────┐\n    │ Code  │──▶│ Lint  │──▶│ Test  │──▶│Deploy │\n    └───────┘   └───┬───┘   └───┬───┘   └───┬───┘\n                    │           │           │\n                    ▼           ▼           ▼\n                   FAIL?       FAIL?       FAIL?\n                    │           │           │\n                    ▼           ▼           ▼\n                  STOP!       STOP!      ROLLBACK!\n                  \n    Early detection = Lower cost to fix"},{id:"principle-10",title:"10. Prompts as Code",content:'PRINCIPLE: Version, review, and tune prompts like code.\n\nWhat it means:\n• Prompts live in version control\n• Changes go through review\n• Tune based on failure modes\n\nWhy it matters:\n• Prompts are the "code" that controls AI behavior\n• Bad prompts → bad AI output\n• Prompts drift needs tracking like code drift\n\nBest practices:\n• Store prompts in prompts.md\n• Log which prompts produced which results\n• A/B test prompt changes\n• Add guardrails for known failure modes',diagram:"    prompts.md:\n    ┌─────────────────────────────────────────────────┐\n    │ ## PROMPT 1 - Initial Setup                     │\n    │                                                 │\n    │ You are the lead engineer running AI-DLC...    │\n    │                                                 │\n    │ Constraints:                                    │\n    │ - Do not implement without approval             │\n    │ - Small batches only                            │\n    │ - Stop at gates                                 │\n    │ ─────────────────────────────────────────────── │\n    │ ## PROMPT 2 - Unit 1 Approval                   │\n    │                                                 │\n    │ Approved. Execute Unit 1...                     │\n    └─────────────────────────────────────────────────┘"},{id:"principles-summary",title:"Principles Summary",content:"You've learned all 10 core AI-DLC principles!\n\nQUICK REFERENCE:\n1. Plan-First — Always plan before executing\n2. Human Accountability — Humans own decisions\n3. Small Batches — Decompose into reviewable units\n4. Adaptive Depth — Match rigor to risk\n5. Structured Q&A — File-based questions/answers\n6. Proof over Prose — Evidence, not claims\n7. Auditable Trail — Append-only decision logs\n8. Context Persistence — Artifacts in-repo\n9. Fail Fast — Validate early, have rollback\n10. Prompts as Code — Version and tune prompts\n\nThese principles work together to create a safe,\neffective, and accountable AI-human collaboration.",diagram:"╭───────────────────────────────────────────╮\n│                                           │\n│   ✓ Lesson Complete: 10 Core Principles  │\n│                                           │\n│   Now try the Practice mode to test      │\n│   your understanding!                     │\n│                                           │\n╰───────────────────────────────────────────╯"}]},{id:"inception-deep-dive",title:"Phase: Inception",description:"Deep dive into the Inception phase",sections:[{id:"inception-overview",title:"Inception Overview",content:"The INCEPTION phase determines WHAT to build and WHY.\n\nGoal: Convert intent into testable, decomposed work.\n\nKey ritual: MOB ELABORATION\n• Conducted with shared screen and facilitator\n• AI proposes breakdown into stories and units\n• Team (PO, Devs, QA, stakeholders) reviews and refines\n• Compresses weeks of sequential work into hours\n\nKey outcomes:\n• Clear requirements documented\n• Work broken into Units (comparable to DDD subdomains)\n• Risks identified with mitigations\n• Explicit approval to proceed\n\nInception answers:\n• What problem are we solving?\n• Who are the users?\n• What are the constraints?\n• How will we measure success?",diagram:"╭───────────────────────────────────────────────────────────╮\n│                    INCEPTION PHASE                        │\n│              (WHAT + WHY via Mob Elaboration)             │\n├───────────────────────────────────────────────────────────┤\n│                                                           │\n│  INPUT:                     OUTPUT:                       │\n│  • User intent              • requirements.md             │\n│  • Business context         • nfr.md + risks.md           │\n│  • Constraints              • user-stories.md             │\n│                             • units/ (one per unit)       │\n│                             • execution-plan.md           │\n│                                                           │\n│  GATE: Requirements + Units Approved                      │\n│                                                           │\n╰───────────────────────────────────────────────────────────╯"},{id:"inception-stages",title:"Inception Stages",content:"Inception has several stages (adaptive based on complexity):\n\n1. WORKSPACE DETECTION\n   • Is this greenfield or brownfield?\n   • What's the tech stack?\n\n2. REVERSE ENGINEERING (brownfield only)\n   • Analyze existing architecture\n   • Map dependencies\n   • Identify technical debt\n\n3. REQUIREMENTS ANALYSIS (mandatory)\n   • Elaborate intent\n   • Document functional requirements\n   • Clarify constraints\n\n4. USER STORIES (if UI/multiple users)\n   • Define personas\n   • Document user journeys\n\n5. WORKFLOW PLANNING (mandatory)\n   • Determine which stages to run\n   • Create execution plan\n\n6. APPLICATION DESIGN (if new components)\n   • High-level architecture\n   • Component responsibilities\n\n7. UNITS GENERATION (if decomposable)\n   • Break into parallel units\n   • Define acceptance criteria",diagram:"    INCEPTION FLOW:\n    \n    ┌──────────────┐\n    │  Workspace   │\n    │  Detection   │\n    └──────┬───────┘\n           │\n           ▼\n    ┌──────────────┐    ┌──────────────┐\n    │   Reverse    │◀───│  Brownfield? │\n    │  Engineering │    └──────────────┘\n    └──────┬───────┘\n           │\n           ▼\n    ┌──────────────┐\n    │ Requirements │ ◀── MANDATORY\n    │   Analysis   │\n    └──────┬───────┘\n           │\n           ▼\n    ┌──────────────┐\n    │   Workflow   │ ◀── MANDATORY\n    │   Planning   │\n    └──────┬───────┘\n           │\n           ▼\n    ┌──────────────┐\n    │    Units     │\n    │  Generation  │\n    └──────┬───────┘\n           │\n           ▼\n       INCEPTION\n         EXIT"},{id:"inception-complete",title:"Inception Complete",content:"You've completed the Inception deep dive!\n\nKEY TAKEAWAYS:\n\n• Inception = WHAT + WHY via Mob Elaboration\n• Mandatory stages: Requirements, Workflow Planning\n• Conditional stages based on project type\n• Key artifacts: Units and Bolts for decomposition\n• Artifacts persist in aidlc-docs/inception/\n• Exit gate requires human approval\n\nNEXT:\n• Explore Construction phase\n• Try the Stage Simulator\n• Test your knowledge with Practice mode",diagram:"╭───────────────────────────────────────────╮\n│                                           │\n│   ✓ Lesson Complete: Inception Phase     │\n│                                           │\n│   Ready to explore Construction?          │\n│                                           │\n╰───────────────────────────────────────────╯"}]}];function s(e){return i.find(n=>n.id===e)}},3633:function(e,n,t){t.d(n,{ProgressProvider:function(){return p},S:function(){return d}});var i=t(7437),s=t(2265),o=t(8854),r=t(6649),a=t(6784);let l=(0,s.createContext)(void 0),c={xp:0,level:1,title:"Novice",lessons:{completed:[],inProgress:{}},quiz:{completed:!1,lastScore:0,bestScore:0,attempts:0},gatekeeper:{completed:!1,lastScore:0,bestScore:0,attempts:0},simulator:{runs:0,requestTypesExplored:[],lastRun:null},achievements:[]};function p(e){let{children:n}=e,[t,p]=(0,s.useState)(c),[d,u]=(0,s.useState)(o.LI),[m,h]=(0,s.useState)(!1);(0,s.useEffect)(()=>{let e=(0,o.jw)();u(e),p((0,o.i)(e)),h(!0)},[]);let g=(0,s.useCallback)(e=>{u(e),p((0,o.i)(e)),(0,o.zL)(e)},[]),f=(0,s.useCallback)(function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,t=(0,r.J8)(e,n),i=d.gamification.xp+t,{level:s,title:l}=(0,r.IN)(i),c={...d,gamification:{xp:i,level:s,title:l}},p=(0,o.i)(c),u=(0,a.nx)(p);if(u.length>0){c.achievements.unlocked=[...c.achievements.unlocked,...u];let e=u.length*(0,r.J8)("achievement_unlocked");c.gamification.xp+=e;let n=(0,r.IN)(c.gamification.xp);c.gamification.level=n.level,c.gamification.title=n.title}return g(c),t},[d,g]),v=(0,s.useCallback)(e=>{if(d.lessons.completed.includes(e))return;let n={...d,lessons:{...d.lessons,completed:[...d.lessons.completed,e],inProgress:{...d.lessons.inProgress}}};delete n.lessons.inProgress[e],g(n),f("lesson_completed")},[d,g,f]),A=(0,s.useCallback)((e,n)=>{var t;g({...d,lessons:{...d.lessons,inProgress:{...d.lessons.inProgress,[e]:{startedAt:(null===(t=d.lessons.inProgress[e])||void 0===t?void 0:t.startedAt)||new Date().toISOString(),lastSection:n}}}}),f("lesson_section")},[d,g,f]),I=(0,s.useCallback)((e,n)=>{g({...d,quiz:{completed:!0,lastScore:e,totalQuestions:n,attempts:d.quiz.attempts+1,bestScore:Math.max(d.quiz.bestScore,e)}}),f("quiz_correct",e),f("quiz_completed"),e===n&&f("quiz_perfect")},[d,g,f]),S=(0,s.useCallback)((e,n)=>{g({...d,gatekeeper:{completed:!0,lastScore:e,totalScenarios:n,attempts:d.gatekeeper.attempts+1,bestScore:Math.max(d.gatekeeper.bestScore,e)}}),f("gate_correct",e),f("gate_completed")},[d,g,f]),y=(0,s.useCallback)(e=>{let n=d.simulator.requestTypesExplored,t=!n.includes(e);g({...d,simulator:{runs:d.simulator.runs+1,requestTypesExplored:t?[...n,e]:n,lastRun:new Date().toISOString()}}),f("simulator_run"),t&&f("simulator_new_type")},[d,g,f]),w=(0,s.useCallback)(()=>{g({...o.LI,firstOpened:d.firstOpened,theme:d.theme})},[d,g]);return m?(0,i.jsx)(l.Provider,{value:{state:t,addXp:f,markLessonCompleted:v,updateLessonProgress:A,saveQuizResult:I,saveGatekeeperResult:S,recordSimulationRun:y,resetProgress:w},children:n}):null}function d(){let e=(0,s.useContext)(l);if(void 0===e)throw Error("useProgress must be used within a ProgressProvider");return e}},6784:function(e,n,t){t.d(n,{iA:function(){return o},nx:function(){return s}});let i=[{id:"first-steps",name:"First Steps",description:"Complete your first lesson",icon:"\uD83C\uDFAF",check:e=>e.lessons.completed.length>=1},{id:"scholar",name:"Scholar",description:"Complete all lessons",icon:"\uD83D\uDCDA",check:e=>e.lessons.completed.length>=3},{id:"quiz-master",name:"Quiz Master",description:"Score 80%+ on the quiz",icon:"\uD83C\uDFC6",check:e=>e.quiz.bestScore>=20},{id:"perfect-score",name:"Perfect Score",description:"Get 100% on the quiz",icon:"⭐",check:e=>e.quiz.bestScore>=24},{id:"gatekeeper",name:"Gatekeeper",description:"Score 80%+ on gatekeeper scenarios",icon:"\uD83D\uDEAA",check:e=>e.gatekeeper.bestScore>=8},{id:"simulator-explorer",name:"Simulator Explorer",description:"Explore all 4 request types",icon:"\uD83D\uDD2C",check:e=>e.simulator.requestTypesExplored.length>=4},{id:"completionist",name:"Completionist",description:"Complete everything",icon:"\uD83D\uDC51",check:e=>{let n=e.lessons.completed.length>=3,t=e.quiz.bestScore>=20,i=e.gatekeeper.bestScore>=8,s=e.simulator.requestTypesExplored.length>=4;return n&&t&&i&&s}}];function s(e){let n=[];for(let t of i)!e.achievements.includes(t.id)&&t.check(e)&&n.push(t.id);return n}function o(e){return i.filter(n=>e.achievements.includes(n.id))}},8854:function(e,n,t){t.d(n,{DV:function(){return d},LI:function(){return o},i:function(){return c},jw:function(){return a},jz:function(){return p},zL:function(){return l}});let i="aidlc-explainer-state",s="state-v1",o={$schema:s,version:"1.0.0",lastUpdated:new Date().toISOString(),firstOpened:new Date().toISOString(),quiz:{completed:!1,lastScore:0,totalQuestions:24,attempts:0,bestScore:0},gatekeeper:{completed:!1,lastScore:0,totalScenarios:10,attempts:0,bestScore:0},lessons:{completed:[],inProgress:{}},simulator:{runs:0,requestTypesExplored:[],lastRun:null},achievements:{unlocked:[]},gamification:{xp:0,level:1,title:"Novice"},theme:"dark"};function r(){try{let e="__storage_test__";return localStorage.setItem(e,e),localStorage.removeItem(e),!0}catch(e){return!1}}function a(){if(!r())return console.warn("localStorage not available, using default state"),{...o};try{let e=localStorage.getItem(i);if(!e)return{...o,firstOpened:new Date().toISOString()};let n=JSON.parse(e);if(n.$schema!==s)return console.warn("Invalid state schema, resetting to defaults"),{...o};return{...o,...n,quiz:{...o.quiz,...n.quiz},gatekeeper:{...o.gatekeeper,...n.gatekeeper},lessons:{...o.lessons,...n.lessons},simulator:{...o.simulator,...n.simulator},achievements:{...o.achievements,...n.achievements},gamification:{...o.gamification,...n.gamification}}}catch(e){return console.error("Failed to load state:",e),{...o}}}function l(e){if(!r())return console.warn("localStorage not available, state not persisted"),!1;try{let n=JSON.stringify({...e,$schema:s,lastUpdated:new Date().toISOString()});return localStorage.setItem(i,n),!0}catch(e){return console.error("Failed to save state:",e),!1}}function c(e){return{xp:e.gamification.xp,level:e.gamification.level,title:e.gamification.title,lessons:{completed:e.lessons.completed,inProgress:Object.fromEntries(Object.entries(e.lessons.inProgress).map(e=>{let[n,t]=e;return[n,{lastSection:t.lastSection}]}))},quiz:{completed:e.quiz.completed,lastScore:e.quiz.lastScore,bestScore:e.quiz.bestScore,attempts:e.quiz.attempts},gatekeeper:{completed:e.gatekeeper.completed,lastScore:e.gatekeeper.lastScore,bestScore:e.gatekeeper.bestScore,attempts:e.gatekeeper.attempts},simulator:{runs:e.simulator.runs,requestTypesExplored:e.simulator.requestTypesExplored,lastRun:e.simulator.lastRun},achievements:e.achievements.unlocked}}function p(){return a().theme}function d(e){let n=a();n.theme=e,l(n)}},6649:function(e,n,t){t.d(n,{IN:function(){return r},It:function(){return l},J8:function(){return o},KM:function(){return a}});let i={lesson_completed:100,lesson_section:10,quiz_correct:25,quiz_completed:50,quiz_perfect:200,gate_correct:30,gate_completed:75,simulator_run:20,simulator_new_type:50,achievement_unlocked:100},s=[{threshold:0,title:"Novice"},{threshold:100,title:"Apprentice"},{threshold:300,title:"Practitioner"},{threshold:600,title:"Specialist"},{threshold:1e3,title:"Expert"},{threshold:1500,title:"Master"},{threshold:2500,title:"Grandmaster"},{threshold:4e3,title:"AI-DLC Champion"}];function o(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Math.floor((i[e]||0)*n)}function r(e){let n=1,t="Novice";for(let i=0;i<s.length;i++)if(e>=s[i].threshold)n=i+1,t=s[i].title;else break;return{level:n,title:t}}function a(e){for(let{threshold:n}of s)if(n>e)return{xpToNext:n-e,nextThreshold:n};return{xpToNext:0,nextThreshold:s[s.length-1].threshold}}function l(e){let{level:n}=r(e);if(n>=s.length)return 100;let t=s[n-1].threshold;return Math.min(100,Math.floor((e-t)/(s[n].threshold-t)*100))}}}]);